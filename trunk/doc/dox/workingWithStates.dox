/**
\page workingWithStates Working with States and Manifolds

\section stateAlloc Allocating memory for states

\li The simple version:\n
\code
ompl::base::StateManifoldPtr manifold(new T());
ompl::base::ScopedState<> state(manifold);
\endcode
or
\code
ompl::base::SpaceInformationPtr si(manifold);
ompl::base::ScopedState<T> state(si);
\endcode
The ompl::base::ScopedState class will do the necessary
memory operations to allocate a state from the correct
manifold. This is the recommended way of allocating states
for code other than ompl internals. Convenience operators such
as = and == are provided. If a type T is provided, where T is 
a manifold type, the maintained state is cast as T::StateType.
operator= will use ompl::base::StateManifold::copyState() and
 operator== will use ompl::base::StateManifold::equalStates().

\li The expert version:\n
\code
ompl::base::SpaceInformationPtr si(manifold);
ompl::base::State* state = si->allocState();
...
si->freeState(state);
\endcode
The structure of a state depends on a manifold
specification. The ompl::base::State type is just an abstract base for
the states of other manifolds.  For this reason, states
cannot be allocated directly, but through the use of a
manifold's allocation mechanism:
ompl::base::StateManifold::allocState(). States are to be
freed using ompl::base::StateManifold::freeState(). For
convenience, ompl::base::SpaceInformation::allocState()
and ompl::base::SpaceInformation::freeState() are defined
as well. Using the calls from the ompl::base::SpaceInformation class
is better since they certainly use the same manifold as
the one used for planning.  This is the lowest level of
operating on states and only recomended for expert users.

See \ref stateOps for how to fill the contents of the
allocated states.


\section stateOps Operating with states

In order for states to be useful in setting start (or goal) positions,
accessing their content is needed. It is assumed the reader is
familiar with \ref stateAlloc.  Furthermore, \ref
stateAndManifoldOperators "operators on states and manifolds" are also
used.

\li Simple version:\n 
The recommended use of states is with ompl::base::ScopedState. Given
the instance of a manifold, this class will allocate a state from that
manifold. The internally maintained state is freed when the instance
of ompl::base::ScopedState goes out of scope.  ompl::base::ScopedState
is a templated class and it inherits from T::StateType, where T is a manifold type. This allows it
to cast the state it maintains to the desired type and thus exhibit
the functionality (the same members) as T::StateType. If no template
argument is specified, the internal state is kept as
ompl::base::State*.
\code
ompl::base::StateManifoldPtr manifold(new ompl::base::SE2StateManifold());
ompl::base::ScopedState<ompl::base::SE2StateManifold> state(manifold);
state->setX(0.1);
state->setY(0.2);
state->setYaw(0.0);

ompl::base::ScopedState<> backup = state;
// backup maintains its internal state as State*, so setX() is not available.
// the content of backup is copied from state

ompl::base::State *abstractState = manifold->allocState();


// this will copy the content of abstractState to state and 
// cast it internall as  ompl::base::SE2StateManifold::StateType
state = abstractState;

// restore state to it's original value
state = backup;

if (state != backup)
   throw ompl::Exception("This should never happen");
\endcode
Combining ompl::base::ScopedState with ompl::base::CompoundStateManifold:
\code
ompl::base::CompoundStateManifold *cm = new ompl::base::CompoundStateManifold();
cm->addSubManifold(ompl::base::StateManifoldPtr(new ompl::base::SO2StateManifold()), 1.0);
cm->addSubManifold(ompl::base::StateManifoldPtr(new ompl::base::SO3StateManifold()), 1.0);

// put the pointer to the manifold in a shared pointer
ompl::base::StateManifoldPtr manifold(cm);

// the ompl::base::ScopedState helps only with one cast here, since we still need to 
// manually cast the components of the state to what we want them to be.
ompl::base::ScopedState<ompl::base::CompoundManifold> state(manifold);
state->as<ompl::base::SO2StateManifold::StateType>(0)->setIdentity();
\endcode
The code above can be equivalently written as:
\code
// define the individual manifolds
ompl::base::StateManifoldPtr so2(new ompl::base::SO2StateManifold());
ompl::base::StateManifoldPtr so3(new ompl::base::SO3StateManifold());

// construct a compound manifold using the overloaded operator+
ompl::base::StateManifoldPtr manifold = so2 + so3;

// the ompl::base::ScopedState helps only with one cast here, since we still need to 
// manually cast the components of the state to what we want them to be.
ompl::base::ScopedState<ompl::base::CompoundManifold> state(manifold);
state->as<ompl::base::SO2StateManifold::StateType>(0)->setIdentity();
\endcode
States can also be printed to streams:
\code
ompl::base::ScopedState<> state(manifold);
std::cout << state;
\endcode
Sometimes it may be useful to extract parts of a state, or assign only
to some parts of a state, especially when using compound manifolds:
\code
// an SE2 manifold is in fact a compound manifold consisting of R^2 and SO2
ompl::base::StateManifoldPtr manifold(new ompl::base::SE2StateManifold());
// define a full state for this manifold
ompl::base::ScopedState<ompl::base::SE2StateManifold> fullState(manifold);
// set the state to a random value
fullState.random();

// construct a state that corresponds to the position component of SE2 
ompl::base::ScopedState<> pos(manifold->as<ompl::base::SE2StateManifold>()->getSubManifold(0));

// copy the position 
pos << fullState;

// equivalently, this can be done too:
fullState >> pos;

// if we now modify pos somehow, we can set it back in the full state:
pos >> fullState;
\endcode
\li Expert version:\n	    
For a manifold type of type T, the result of
ompl::base::StateManifold::allocState() can be casted to
T::StateType* to gain access to the state's members. To
ease this functionality, the ompl::base::State::as()
functions have been defined.
\code
ompl::base::StateManifoldPtr manifold(new ompl::base::RealVectorStateManifold(1));
ompl::base::State *state = manifold->allocState();
state->as<ompl::base::RealVectorStateManifold::StateType>()->values[0] = 0.1;
ompl::base::State *copy = manifold->allocState();
manifold->copyState(copy, state);
if (!manifold->equalStates(copy, state))
   throw ompl::Exception("This should not happen");
manifold->freeState(state);
manifold->freeState(copy);
\endcode

*/
