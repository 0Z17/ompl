/** \page benchmark How to benchmark planners

    Benchmarking a set of planners on a specified problem is a simple
    task in OMPL. The following code snippet shows you how to do it.
    Some initial code that you probably have already used:
    \code   
    #include "ompl/geometric/Benchmark.h"
    ...
    using namespace ompl;
    ...

    // A function that matches the PlannerAllocator type.
    // It will be used later to allocate an instance of EST
    base::PlannerPtr myConfiguredPlanner(const base::SpaceInformationPtr &si)
    {
	geometric::EST *est = new geometric::EST(si);
	est->setRange(100.0);
	return base::PlannerPtr(est);
    }

    // Create a manifold for the space we are planning in
    ompl::geometric::SimpleSetup ss(manifold);

    // Configure the problem to solve: set start state(s)
    // and goal representation
    // Everything must be set up to the point ss.solve()
    // can be called. Setting up a planner is not needed.
    \endcode

    Benchmarking code starts here:
    \code
    // First we create a benchmark class:
    ompl::geometric::Benchmark b(ss);

    // We add the planners to evaluate.
    b.addPlanner(base::PlannerPtr(new geometric::KPIECE1(ss.getSpaceInformation())));
    b.addPlanner(base::PlannerPtr(new geometric::RRT(ss.getSpaceInformation())));
    b.addPlanner(base::PlannerPtr(new geometric::SBL(ss.getSpaceInformation())));
    b.addPlanner(base::PlannerPtr(new geometric::LBKPIECE1(ss.getSpaceInformation())));
    // etc

    // For planners that we want to configure in specific ways,
    // the base::PlannerAllocator should be used:
    b.addPlanner(boost::bind(&myConfiguredPlanner, _1));
    // etc


    // Now we can benchmark: 5 second time limit for each plan computation,
    // 100 MB maximum memory usage per plan computation, 50 runs for each planner
    // and true means that a text-mode progress bar should be displayed while
    // computation is running.
    b.benchmark(5, 100, 50, true);

    // This will generate a file of the form ompl_host_time.log
    b.saveResultsToFile();
    \endcode

    Once the C++ code computing the results has been executed, a .log
    file is generated. This contains information about the settings of
    the planners, the parameters of the problem tested on, etc.    
    To visualize this information, we first need to parse it:
    \code
    scripts/benchmark_statistics.py logfile.log -d mydatabase.db
    \endcode
    This will generate a SQLite database containing the parsed data. If no 
    database name is specified, the named is assumed to be benchmark.db
    Once this database is generated, we can construct plots:
    \code
    scripts/benchmark_statistics.py -d mydatabase.db -b boxplot.pdf
    \endcode
    If you would like to process the data in different ways, you can generate 
    a dump file that you can load in a MySQL database:
    \code
    scripts/benchmark_statistics.py -d mydatabase.db -m mydump.sql
    \endcode
    The database will contain 2+k tables:
    - \e planners is a table that contains planner configurations
    - \e experiments is a table that contains details about conducted experiments
    - k tables named \e planner_<name>, one for each planner, containing measurements

    For more details on how to use the benchmark script, see:
    \code
    scripts/benchmark_statistics.py --help
    \endcode


    At this point, only benchmarking for geometric planners is implemented.	
*/