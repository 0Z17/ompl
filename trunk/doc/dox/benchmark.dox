/** \page benchmark How to benchmark planners

    Benchmarking a set of planners on a specified problem is a simple
    task in OMPL. The following code snippet shows you how to do it.
    Some initial code that you probably have already used:
    \code   
    #include "ompl/geometric/Benchmark.h"
    ...
    using namespace ompl;
    ...

    // A function that matches the PlannerAllocator type.
    // It will be used later to allocate an instance of EST
    base::PlannerPtr myConfiguredPlanner(const base::SpaceInformationPtr &si)
    {
	geometric::EST *est = new geometric::EST(si);
	est->setRange(100.0);
	return base::PlannerPtr(est);
    }

    // Create a manifold for the space we are planning in
    ompl::geometric::SimpleSetup ss(manifold);

    // Configure the problem to solve: set start state(s)
    // and goal representation
    // Everything must be set up to the point ss.solve()
    // can be called. Setting up a planner is not needed.
    \endcode

    Benchmarking code starts here:
    \code
    // First we create a benchmark class:
    ompl::geometric::Benchmark b(ss);

    // We add the planners to evaluate.
    b.addPlanner(base::PlannerPtr(new geometric::KPIECE1(ss.getSpaceInformation())));
    b.addPlanner(base::PlannerPtr(new geometric::RRT(ss.getSpaceInformation())));
    b.addPlanner(base::PlannerPtr(new geometric::SBL(ss.getSpaceInformation())));
    b.addPlanner(base::PlannerPtr(new geometric::LBKPIECE1(ss.getSpaceInformation())));
    // etc

    // For planners that we want to configure in specific ways,
    // the base::PlannerAllocator should be used:
    b.addPlanner(boost::bind(&myConfiguredPlanner, _1));
    // etc


    // Now we can benchmark: 5 second time limit for each plan computation,
    // 100 MB maximum memory usage per plan computation, 50 runs for each planner
    // and true means that a text-mode progress bar should be displayed while
    // computation is running.
    b.benchmark(5, 100, 50, true);

    // This will generate a file of the form ompl_host_time.log
    b.saveResultsToFile();
    \endcode

    Once the C++ code computing the results has been executed, a .log
    file is generated. This contains information about the settings of
    the planners, the parameters of the problem tested on, etc.    
    To visualize this information, we first need to parse it:
    \code
    scripts/benchmark_statistics.py logfile.log -d mydatabase.db
    \endcode
    This will generate a SQLite database containing the parsed data. If no 
    database name is specified, the named is assumed to be benchmark.db
    Once this database is generated, we can construct plots:
    \code
    scripts/benchmark_statistics.py -d mydatabase.db -p boxplot.pdf
    \endcode
    If you would like to process the data in different ways, you can generate 
    a dump file that you can load in a MySQL database:
    \code
    scripts/benchmark_statistics.py -d mydatabase.db -m mydump.sql
    \endcode
    The database will contain 2+k tables:
    - \e planners is a table that contains planner configurations
    - \e experiments is a table that contains details about conducted experiments
    - k tables named \e planner_<name>, one for each planner, containing measurements

    For more details on how to use the benchmark script, see:
    \code
    scripts/benchmark_statistics.py --help
    \endcode

    Collected benchmark data for each experiment:
    - <strong>name:</strong> name of experiment (optional)
    - <strong>totaltime:</strong> the total duration for conducting the experiment (seconds)
    - <strong>timelimit:</strong> the maximum time allowed for every planner execution (seconds)
    - <strong>memorylimit:</strong> the maximum memory allowed for every planner execution (MB)
    - <strong>hostname:</strong> the name of the host on which the experiment was run
    - <strong>date:</strong> the date and time when the experiment was started
      	    
    Collected benchmark data for each planner execution:
    - <strong>solved:</strong> (boolean) flag indicating whether the planner found a solution
    - <strong>time:</strong> (real) the amount of time spent planning, in seconds
    - <strong>memory:</strong> (real) the amount of memory spent planning, in MB. Note: this may be inaccurate since memory is often freed in a lazy fashion
    - <strong>preallocated states:</strong> (integer) the number of states that are allocated by ompl::base::StateAllocator but not used anywhere
    - <strong>approximate solution:</strong> (boolean) flag indicating whether the found solution is approximate (does not reach the goal) 
    - <strong>solution difference:</strong> (real) if solution is approximate, this is the distance from the end-point of the found approximate solution to the actual goal
    - <strong>solution length:</strong> (real) the length of the found solution
    - <strong>correct solution:</strong> (boolean) flag indicating whether the found solution is correct. This should always be true.
    - <strong>correct solution strict:</strong> (boolean) flag indicating whether the found solution is correct when checked at a finer resolution.
    - <strong>simplification time:</strong> (real) the time spend simplifying the solution path, in seconds
    - <strong>simplified solution length:</strong> (real) the length of the found solution after simplification
    - <strong>simplified correct solution:</strong> (boolean) flag indicating whether the found solution is correct after simplification. This should always be true.
    - <strong>simplified correct solution strict:</strong> (boolean) flag indicating whether the found solution is correct after simplification, when checked at a finer resolution.
    - <strong>graph states:</strong> (integer) the number of states in the constructed graph
    - <strong>graph motions:</strong> (integer) the number of edges (motions) in the constructed graph
    - more planner-specific properties

    At this point, only benchmarking for geometric planners is implemented.	
*/